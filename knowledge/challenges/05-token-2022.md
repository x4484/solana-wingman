# Challenge 5: Token-2022 Extensions

## TLDR

Explore the next generation of Solana tokens with Token-2022 (Token Extensions). Learn transfer hooks, confidential transfers, transfer fees, and other powerful features not available in the original SPL Token program.

## Core Concepts

### What You're Building

A token with modern extensions:
1. Transfer fees (automatic fee on every transfer)
2. Transfer hooks (custom logic on transfers)
3. Interest-bearing tokens
4. Non-transferable tokens (soulbound)

### SPL Token vs Token-2022

| Feature | SPL Token | Token-2022 |
|---------|-----------|------------|
| Program ID | `TokenkegQEF...` | `TokenzQdBN...` |
| Transfer hooks | ❌ | ✅ |
| Transfer fees | ❌ | ✅ |
| Confidential transfers | ❌ | ✅ |
| Interest bearing | ❌ | ✅ |
| Non-transferable | ❌ | ✅ |
| Metadata pointer | ❌ | ✅ |
| Permanent delegate | ❌ | ✅ |

### Extension Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    TOKEN-2022 MINT                       │
├─────────────────────────────────────────────────────────┤
│  Base Mint Data (same as SPL Token)                     │
│  - supply, decimals, mint_authority, freeze_authority   │
├─────────────────────────────────────────────────────────┤
│  Extension: TransferFee                                 │
│  - fee_basis_points: 100 (1%)                          │
│  - max_fee: 1_000_000                                  │
│  - transfer_fee_authority                              │
├─────────────────────────────────────────────────────────┤
│  Extension: TransferHook                                │
│  - program_id: <your hook program>                     │
│  - authority                                           │
├─────────────────────────────────────────────────────────┤
│  Extension: MetadataPointer                            │
│  - metadata_address: <metadata account>                │
└─────────────────────────────────────────────────────────┘
```

## Project Setup

```bash
# Add Token-2022 dependencies
cargo add spl-token-2022 anchor-spl

# Cargo.toml
[dependencies]
anchor-lang = "0.30.0"
anchor-spl = { version = "0.30.0", features = ["token-2022"] }
spl-token-2022 = "3.0"
```

## Code Walkthrough

### 1. Create Token with Transfer Fees

```rust
use anchor_lang::prelude::*;
use anchor_spl::token_2022::{
    self,
    Token2022,
    spl_token_2022::{
        extension::{
            transfer_fee::{TransferFeeConfig, MAX_FEE_BASIS_POINTS},
            ExtensionType,
        },
        state::Mint,
    },
};

declare_id!("YOUR_PROGRAM_ID");

#[program]
pub mod token_2022_example {
    use super::*;

    /// Create a mint with transfer fee extension
    pub fn create_transfer_fee_mint(
        ctx: Context<CreateMint>,
        decimals: u8,
        fee_basis_points: u16,  // 100 = 1%
        max_fee: u64,
    ) -> Result<()> {
        require!(
            fee_basis_points <= MAX_FEE_BASIS_POINTS,
            TokenError::FeeTooHigh
        );

        // Calculate space needed for mint + extensions
        let extension_types = vec![ExtensionType::TransferFeeConfig];
        let space = ExtensionType::try_calculate_account_len::<Mint>(&extension_types)?;

        // Create account with extra space for extensions
        let lamports = Rent::get()?.minimum_balance(space);
        
        anchor_lang::system_program::create_account(
            CpiContext::new(
                ctx.accounts.system_program.to_account_info(),
                anchor_lang::system_program::CreateAccount {
                    from: ctx.accounts.payer.to_account_info(),
                    to: ctx.accounts.mint.to_account_info(),
                },
            ),
            lamports,
            space as u64,
            &token_2022::ID,
        )?;

        // Initialize transfer fee extension
        spl_token_2022::extension::transfer_fee::instruction::initialize_transfer_fee_config(
            &token_2022::ID,
            &ctx.accounts.mint.key(),
            Some(&ctx.accounts.authority.key()),  // transfer_fee_config_authority
            Some(&ctx.accounts.authority.key()),  // withdraw_withheld_authority
            fee_basis_points,
            max_fee,
        )?;

        // Initialize mint
        token_2022::initialize_mint2(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                token_2022::InitializeMint2 {
                    mint: ctx.accounts.mint.to_account_info(),
                },
            ),
            decimals,
            &ctx.accounts.authority.key(),
            Some(&ctx.accounts.authority.key()),
        )?;

        msg!("Created mint with {}% transfer fee", fee_basis_points as f64 / 100.0);
        Ok(())
    }

    /// Harvest fees from token accounts
    pub fn harvest_fees(ctx: Context<HarvestFees>) -> Result<()> {
        // Fees are "withheld" in destination accounts
        // Authority can harvest them to a designated account
        
        let harvest_accounts = vec![ctx.accounts.source_account.to_account_info()];
        
        spl_token_2022::extension::transfer_fee::instruction::harvest_withheld_tokens_to_mint(
            &token_2022::ID,
            &ctx.accounts.mint.key(),
            &harvest_accounts.iter().map(|a| a.key()).collect::<Vec<_>>(),
        )?;

        msg!("Harvested withheld fees to mint");
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMint<'info> {
    /// CHECK: Will be initialized as Token-2022 mint
    #[account(mut)]
    pub mint: Signer<'info>,

    #[account(mut)]
    pub payer: Signer<'info>,

    pub authority: Signer<'info>,

    pub token_program: Program<'info, Token2022>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct HarvestFees<'info> {
    #[account(mut)]
    pub mint: AccountInfo<'info>,

    #[account(mut)]
    pub source_account: AccountInfo<'info>,

    pub authority: Signer<'info>,

    pub token_program: Program<'info, Token2022>,
}

#[error_code]
pub enum TokenError {
    #[msg("Fee basis points too high")]
    FeeTooHigh,
}
```

### 2. Transfer Hook Program

Transfer hooks let you run custom logic on every transfer:

```rust
use anchor_lang::prelude::*;
use spl_transfer_hook_interface::instruction::ExecuteInstruction;

declare_id!("YOUR_HOOK_PROGRAM_ID");

#[program]
pub mod transfer_hook {
    use super::*;

    /// Called by Token-2022 on every transfer
    pub fn execute(ctx: Context<Execute>, amount: u64) -> Result<()> {
        // Your custom logic here!
        
        // Example: Log all transfers
        msg!(
            "Transfer hook: {} tokens from {} to {}",
            amount,
            ctx.accounts.source.key(),
            ctx.accounts.destination.key()
        );

        // Example: Check allowlist
        // require!(
        //     is_allowed(&ctx.accounts.destination.key()),
        //     HookError::NotAllowed
        // );

        // Example: Update analytics
        // let stats = &mut ctx.accounts.transfer_stats;
        // stats.total_volume += amount;
        // stats.transfer_count += 1;

        Ok(())
    }

    /// Required: Fallback for transfer hook interface
    pub fn fallback<'info>(
        _program_id: &Pubkey,
        accounts: &'info [AccountInfo<'info>],
        data: &[u8],
    ) -> Result<()> {
        let instruction = ExecuteInstruction::unpack(data)?;

        // The accounts are in a specific order defined by the interface
        __private::__global::execute(
            Context::new(
                &crate::ID,
                &mut Execute {
                    source: accounts[0].clone(),
                    mint: accounts[1].clone(),
                    destination: accounts[2].clone(),
                    authority: accounts[3].clone(),
                },
                &[],
                BTreeMap::new(),
            ),
            instruction.amount,
        )
    }
}

#[derive(Accounts)]
pub struct Execute<'info> {
    /// CHECK: Validated by Token-2022
    pub source: AccountInfo<'info>,
    
    /// CHECK: Validated by Token-2022
    pub mint: AccountInfo<'info>,
    
    /// CHECK: Validated by Token-2022
    pub destination: AccountInfo<'info>,
    
    /// CHECK: Validated by Token-2022
    pub authority: AccountInfo<'info>,
    
    // Add your own accounts here for custom logic
    // #[account(mut)]
    // pub transfer_stats: Account<'info, TransferStats>,
}
```

### 3. Non-Transferable (Soulbound) Tokens

```rust
/// Create a non-transferable (soulbound) token
pub fn create_soulbound_mint(ctx: Context<CreateMint>, decimals: u8) -> Result<()> {
    let extension_types = vec![ExtensionType::NonTransferable];
    let space = ExtensionType::try_calculate_account_len::<Mint>(&extension_types)?;

    // Create account
    let lamports = Rent::get()?.minimum_balance(space);
    anchor_lang::system_program::create_account(
        CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            anchor_lang::system_program::CreateAccount {
                from: ctx.accounts.payer.to_account_info(),
                to: ctx.accounts.mint.to_account_info(),
            },
        ),
        lamports,
        space as u64,
        &token_2022::ID,
    )?;

    // Initialize non-transferable extension
    spl_token_2022::extension::non_transferable::instruction::initialize(
        &token_2022::ID,
        &ctx.accounts.mint.key(),
    )?;

    // Initialize mint
    token_2022::initialize_mint2(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            token_2022::InitializeMint2 {
                mint: ctx.accounts.mint.to_account_info(),
            },
        ),
        decimals,
        &ctx.accounts.authority.key(),
        None,  // No freeze authority needed
    )?;

    msg!("Created soulbound (non-transferable) mint");
    Ok(())
}
```

### 4. Interest-Bearing Tokens

```rust
/// Create an interest-bearing token
pub fn create_interest_bearing_mint(
    ctx: Context<CreateMint>,
    decimals: u8,
    rate: i16,  // Interest rate in basis points (100 = 1%)
) -> Result<()> {
    let extension_types = vec![ExtensionType::InterestBearingConfig];
    let space = ExtensionType::try_calculate_account_len::<Mint>(&extension_types)?;

    // Create account
    let lamports = Rent::get()?.minimum_balance(space);
    anchor_lang::system_program::create_account(
        CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            anchor_lang::system_program::CreateAccount {
                from: ctx.accounts.payer.to_account_info(),
                to: ctx.accounts.mint.to_account_info(),
            },
        ),
        lamports,
        space as u64,
        &token_2022::ID,
    )?;

    // Initialize interest-bearing extension
    spl_token_2022::extension::interest_bearing_mint::instruction::initialize(
        &token_2022::ID,
        &ctx.accounts.mint.key(),
        Some(ctx.accounts.authority.key()),
        rate,
    )?;

    // Initialize mint
    token_2022::initialize_mint2(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            token_2022::InitializeMint2 {
                mint: ctx.accounts.mint.to_account_info(),
            },
        ),
        decimals,
        &ctx.accounts.authority.key(),
        Some(&ctx.accounts.authority.key()),
    )?;

    msg!("Created interest-bearing mint at {}% APY", rate as f64 / 100.0);
    Ok(())
}
```

## Client-Side: Detecting Token-2022

```typescript
import { 
    TOKEN_PROGRAM_ID, 
    TOKEN_2022_PROGRAM_ID,
    getMint,
    getTransferFeeConfig,
} from "@solana/spl-token";

// Check which program owns a mint
async function getTokenProgram(connection: Connection, mint: PublicKey) {
    const accountInfo = await connection.getAccountInfo(mint);
    
    if (accountInfo.owner.equals(TOKEN_PROGRAM_ID)) {
        return "SPL Token";
    } else if (accountInfo.owner.equals(TOKEN_2022_PROGRAM_ID)) {
        return "Token-2022";
    }
    throw new Error("Unknown token program");
}

// Get transfer fee config
async function getTransferFee(connection: Connection, mint: PublicKey) {
    const mintInfo = await getMint(
        connection,
        mint,
        "confirmed",
        TOKEN_2022_PROGRAM_ID
    );
    
    const feeConfig = getTransferFeeConfig(mintInfo);
    if (feeConfig) {
        console.log(`Fee: ${feeConfig.newerTransferFee.transferFeeBasisPoints} basis points`);
        console.log(`Max fee: ${feeConfig.newerTransferFee.maximumFee}`);
    }
}
```

## Security Considerations

1. **Extension Immutability**: Some extensions can't be changed after mint creation
2. **Transfer Hook Trust**: Hook program has power over all transfers
3. **Fee Authority**: Whoever controls fee authority can change fees
4. **Confidential Transfer Privacy**: Not truly private - amounts are encrypted but visible on-chain

## Common Gotchas

### 1. Using Wrong Program ID
```typescript
// ❌ Wrong: using SPL Token program for Token-2022 mint
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";
await transfer(connection, payer, from, to, owner, amount, [], TOKEN_PROGRAM_ID);

// ✅ Correct: use Token-2022 program
import { TOKEN_2022_PROGRAM_ID } from "@solana/spl-token";
await transfer(connection, payer, from, to, owner, amount, [], TOKEN_2022_PROGRAM_ID);
```

### 2. Forgetting Extra Accounts for Transfer Hooks
```typescript
// ❌ Wrong: hook needs additional accounts
await transfer(connection, payer, from, to, owner, amount);

// ✅ Correct: include hook accounts
const hookAccounts = await getTransferHookExtraAccounts(connection, mint);
await transferCheckedWithHook(
    connection, payer, from, mint, to, owner, amount, decimals, hookAccounts
);
```

### 3. Not Accounting for Transfer Fees
```typescript
// ❌ Wrong: sending exact amount (recipient gets less)
const amount = 1000;
await transfer(..., amount);  // Recipient gets 990 if 1% fee

// ✅ Correct: calculate fee and send more
const fee = calculateFee(amount, feeBasisPoints);
const totalAmount = amount + fee;
await transfer(..., totalAmount);  // Recipient gets 1000
```

### 4. Extension Order Matters
```rust
// Extensions must be initialized BEFORE the mint
// ❌ Wrong order
initialize_mint(...)?;
initialize_transfer_fee_config(...)?;  // Too late!

// ✅ Correct order
initialize_transfer_fee_config(...)?;  // Extensions first
initialize_mint(...)?;                  // Then mint
```

## What You've Learned

- [x] Token-2022 vs SPL Token differences
- [x] Transfer fee extension
- [x] Transfer hooks for custom logic
- [x] Non-transferable (soulbound) tokens
- [x] Interest-bearing tokens
- [x] Extension initialization order
- [x] Client-side Token-2022 detection

## Next Steps

**Challenge 6: Compressed NFTs** - Scale to millions of NFTs cheaply!

## Builder Checklist

- [ ] Created Token-2022 mint with transfer fees
- [ ] Implemented transfer hook program
- [ ] Created soulbound token
- [ ] Created interest-bearing token
- [ ] Harvested withheld fees
- [ ] Detected Token-2022 client-side
- [ ] Calculated fees correctly in transfers
- [ ] (Bonus) Implemented confidential transfers
- [ ] (Bonus) Combined multiple extensions
